<?xml version="1.0"?>
<!--
  Licensed Materials - Property of IBM
  IBM WebSphere DataPower Appliances
  Copyright IBM Corporation 2012,2014. All Rights Reserved.
  US Government Users Restricted Rights - Use, duplication or disclosure
  restricted by GSA ADP Schedule Contract with IBM Corp.
-->

<!-- 
    Foreword:
    The assertions handled by this sample stylesheet are an attempt to mimic
    "real-world" business needs of a fictitious company named JK Life & Wealth
    via policy. The namespace for this policy is "http://lifeandwealth.jk/policy"
    
    The "Introduction" section below provides a simple foundation for
    understanding the role this stylesheet plays in converting policy into
    configuration on a DataPower appliance. The "Summary of Steps" section
    provides more detail and shows a best practice for going about the process
    of authoring a policy vocabulary and using XSLT to convert the policy. The
    remainder of this stylesheet is the actual implementation of the policy to
    configuration conversion utility.

    Introduction:
    This stylesheet should be used as an example of how you should convert your
    policy, based on Web Services Policy 1.2, into the DataPower configuration
    objects necessary to enforce the policy assertions you have defined for your
    policy.
    
    The configuration objects that you generate are the Processing Actions
    (configuration object type: StylePolicyAction) that are needed to enforce
    policy assertions and the objects referenced by the Processing Actions.

      Example: You may decide to create a policy assertion that limits the number
               of messages that are allowed per unit of time. DataPowoer provides
               SLM capability to achieve this result via the SLM Processing action.
               An SLM Processing Action must reference an SLM Policy object.
               This SLM policy must exist in the same DataPower Application
               Domain as the service that uses the policy. This can be achieved
               using a prerequisite SLM policy (placed in the application domain
               in a prior configuration exercise), or it can be defined by this
               stylesheet.

    The Processing Action objects generated by each assertion will automatically
    be added to a Processing Rule (object type: Rule) by DataPower, so this
    stylesheet must not create its own processing rule. It is important to note
    that multiple assertions may be rendered on the same automatically generated
    Processing Rule so the Input and Output contexts used by the Processing
    Actions for each assertion must share context correctly. This is handled in
    this stylesheet by using the input context and output contexts specified in
    the notepad. These values are stored in the following local variables.
        dpe:local-variable('input-context')
        dpe:local-variable('output-context')
        
    An assertion may not care about the input or output context, but all
    assertions must, at a minimum, route the input context to the output context
    using an identity transformation (as shown in the JK-AuditLog assertion) to
    preserve the integrity of the contexts.
    
    DataPower attempts to render the configuration for assertions in the order
    that they appear in policy. This is accomplished by proper use of the
    assertionNo attribute for the dppolicy:config element, so it is important to
    handle this attribute properly. This stylesheet sets assertionNo based on
    the position of the assertion within the <All> element.
      Warning: Beware of the usage of for-each loops to itertate through
               assertions because the position() of each assertion in the
               for-each will be 1. 
    
    Summary of Steps:
    1) Choose your own custom policy domain namespace. This namespace will be used
       by DataPower to identify your policy assertions.
    
        As an example, JKL&W chose the following namespace
           "http://lifeandwealth.jk/policy"
    
    2) Decide on a vocabulary for your policy domain assertions based on your
       business requirements. Create place holder templates for each assertion.
       
        As an example, JKL&W has selected four policy assertions for their custom
        policy domain:
       
         <JK-EnforceAAA/>
         <JK-AuditLog/>
         <JK-NormalizeMessage>
            <Version1/> | <Version2/>
         </JK-NormalizeMessage>
         <JK-RouteMessage/>
       
       Step "2.2": DataPower Policy Parameters may be necessary to provide
       additional information in order to correctly bind the assertion into
       configuration.
       
        As an example, The JK-RouteMessage assertion may need to route messages
        to an SSL backend. To do this a DataPower SSL Proxy Profile must
        be specified so DataPower can properly establish the SSL connection to
        the backend service.
       
       Step "2.3": Create the stylesheet that will translate the policy
       assertions into configuration. It is a best practice to make a copy of
       this stylesheet to use as a starting point. 

    3) Create the DataPower Processing Actions that implement the desired policy
       assertion behavior.
       
        As an example, JKL&W used the DataPower WebGUI to create the necessary
        Processing Actions in an existing Web Service Proxy to implement the
        behavior prescribed for each policy assertion defined in step 2.
    
    4) Export the DataPower configuration created in step 3. This will contain
       the Processing Actions you need to implement your custom policy assertions.
       Extract the applicable configuration (StylePolicyAction objects and
       prerequisite objects, if any) for each policy assertion from the export
       package to use in step 5.
       
        As an example, the export.xml in an exported zip file will contain the
        XML definition of the configuration objects.
       
    5) Apply the extracted configuration to each policy assertion template as
       required to implement each policy assertion.
       
        As an example, JKL&W implemented four XSLT templates in this stylesheet.
        Each of these assertions contains configuration that was inspired by the
        export.xml from step 4. Note that the configuration from export.xml is
        is not used in the assertion verbatim because some elements are optional,
        some element values are calculated by this stylesheet (perhaps a value
        from the policy assertion), and because the context handling requirements
        discussed in the Introduction.
       
         This is best described by comparing the configuration generated by the
         jklw:JK-AuditLog template: 
            <xsl:element name="StylePolicyAction">
                <xsl:attribute name="name"><xsl:value-of select="$actionName"/></xsl:attribute>
                <xsl:element name="Type"><xsl:text>xform</xsl:text></xsl:element>
                <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                <xsl:element name="Output"><xsl:value-of select="dpe:local-variable('output-context')"/></xsl:element>
                <xsl:element name="Transform"><xsl:text>store:///identity.xsl</xsl:text></xsl:element>
                <xsl:element name="OutputType"><xsl:text>default</xsl:text></xsl:element>
            </xsl:element>
    
         To the StylePolicyAction object definition as it appears in the export.xml
            <StylePolicyAction name="echo-fw-10000-policy_rule_5_xform_2" xmlns:env="http://www.w3.org/2003/05/soap-envelope" xmlns:dp="http://www.datapower.com/schemas/management">
              <mAdminState>enabled</mAdminState>
              <Type>xform</Type>
              <Input>INPUT</Input>
              <Transform>store:///identity.xsl</Transform>
              <Output>OUTPUT</Output>
              <NamedInOutLocationType>default</NamedInOutLocationType>
              <OutputType>default</OutputType>
              
              <Transactional>off</Transactional>
              <SOAPValidation>body</SOAPValidation>
              <SQLSourceType>static</SQLSourceType>
              <Asynchronous>off</Asynchronous>
              <ResultsMode>first-available</ResultsMode>
              <RetryCount>0</RetryCount>
              <RetryInterval>1000</RetryInterval>
              <MultipleOutputs>off</MultipleOutputs>
              <IteratorType>XPATH</IteratorType>
              <Timeout>0</Timeout>
              <MethodRewriteType>GET</MethodRewriteType>
              <MethodType>POST</MethodType>
              <MethodType2>POST</MethodType2>
            </StylePolicyAction>

    6) After the implementation for the assertions is complete copy the stylesheet
       created in step 2.3 to the DataPower appliance in the "store:///policies/custom"
       directory, and copy any referenced files (e.g. stylesheets, xml files,
       certificates) to their respective locations.
       
       As an example, A stylesheet referenced by an xform Processing Action may
       be placed in a location like local://jklw-policy/mystylesheet.xsl if it
       needs to be used by policy attached to services that span application
       domains (be sure the directory name does not collide with an Application
       Domain name). If the policy will be used within in a single domain then
       the policy can be placed in that domain and referenced accordingly.
       
    7) Once all the files are in place on the DataPower device, the new policy
       domain may be used immediately.
       
       If at any time a change is needed for the stylesheet created in step 2.3
       then all policy documents that use the policy namespace should be detached and
       reattached in order to recreate the configuration for the policy assertions. 
-->

<!--
   As a convenince the list of assertions that will be supported
   is repeated here from step 2:
   
   <JK-AuditLog/>
   <JK-NormalizeMessage>
      <Version1/>
      <Version2/>
   </JK-NormalizeMessage>
   <JK-RouteMessage/>
   <JK-EnforceAAA/>
-->   
   
<xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:func="http://exslt.org/functions"
    xmlns:dpe="http://www.datapower.com/extensions"
    xmlns:dppolicy="http://www.datapower.com/policy"
    xmlns:dpconfig="http://www.datapower.com/param/config"
    xmlns:dpfunc="http://www.datapower.com/extensions/functions"
    xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy"
    xmlns:jklw="http://lifeandwealth.jk/policy"

    extension-element-prefixes="dpe"
    exclude-result-prefixes="dpe dpconfig dppolicy wsp jklw">

    <!-- ******************************************************** -->
    <!-- (1) Declare the policy domain this stylesheet implements -->
    <!-- ******************************************************** -->

    <dpe:summary xmlns=""> 
        <!-- Comment the following line to prevent the policy domain from being processed -or- remove the comment if you want to process the policy domain. -->
        <!-- <dppolicy:domain>http://lifeandwealth.jk/policy</dppolicy:domain> -->
        <operation>xform</operation>
        <description>Implements policy assertions for JK Life and Wealth</description>
    </dpe:summary>
    
    <!-- **************************************************************** -->
    <!-- (2.2) Declare any required DataPower Policy Parameters that are 
               required for binding and associating policy assertions 
               to configuration                                           -->
    <!-- **************************************************************** -->

    <!-- Specify the SSL Proxy Profile for the route-transform action -->
    <dpe:param name="dpconfig:ws-jklw-SSLProfile" type="dmReference" reftype="SSLProxyProfile" xmlns="">
      <dppolicy:assertion>{http://lifeandwealth.jk/policy}JK-RouteMessage</dppolicy:assertion>
        <display>SSL Proxy Profile</display>
        <description>Specify which SSL Profile will be used for the JK-RouteMessage assertion</description>
    </dpe:param>

    <!-- the policy domain namespace the stylesheet is executed for -->
    <xsl:variable name="seqno" select="/dppolicy:request/dppolicy:header/dppolicy:SequenceNo"/>
    <xsl:variable name="nsuri" select="/dppolicy:request/dppolicy:sequence/DomainNamespace[position()=$seqno]/@uri"/>

    <!-- The following global variables represent the input document -->
    <!-- header with aux information -->
    <xsl:variable name="header" select="/dppolicy:request/dppolicy:header"/>
    <!-- configured policy bindings defined as dpe:param above (Policy Parameters)-->
    <xsl:variable name="bindings" select="/dppolicy:request/dppolicy:bindings"/>
    <!-- ws-policy alternative -->
    <xsl:variable name="policy" select="/dppolicy:request/dppolicy:policy"/>
    <!-- previously generated configuration for this policy alternative -->
    <xsl:variable name="configuration" select="/dppolicy:request/dppolicy:configuration"/>
    <!-- general notepad to pass information between processing steps of one alternative -->
    <xsl:variable name="notepad" select="/dppolicy:request/dppolicy:notepad"/>
    
    <!-- helper variables -->
    <xsl:variable name="rD" select="$header/dppolicy:RequestDomain"/>
    <xsl:variable name="lT" select="$header/dppolicy:LogType"/>
    <xsl:variable name="lC" select="$header/dppolicy:LogClass"/>
    <xsl:variable name="rO" select="$header/dppolicy:RequestObject"/>

    <!-- main -->
    <xsl:template match="/">
        <!-- Get the Input context name (See "Introduction")-->
        <xsl:choose>
            <xsl:when test="string-length($notepad/shared-context/in-context) > 0">
                <dpe:set-local-variable name="'input-context'" value="$notepad/shared-context/in-context"/>
                <xsl:message dpe:priority="debug" dpe:domain="{$rD}" dpe:type="{$lT}" dpe:class="{$lC}" dpe:object="{$rO}">Input context=<xsl:value-of select="dpe:local-variable('input-context')"/></xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes" dpe:priority="error" dpe:domain="{$rD}" dpe:type="{$lT}" dpe:class="{$lC}" dpe:object="{$rO}">Cannot find the input context</xsl:message>
            </xsl:otherwise>
        </xsl:choose>

        <!-- Get the Output context name (See "Introduction")-->
        <!-- Note that each assertion renders its output on dpe:local-variable('output-context') the
             JK-AuditLog assertion does not have any output, so it steers the dpe:local-variable('input-context')
             to the dpe:local-variable('output-context') using an identity transform. -->
        <xsl:choose>
            <xsl:when test="string-length($notepad/shared-context/out-context) > 0">
                <dpe:set-local-variable name="'output-context'" value="$notepad/shared-context/out-context"/>
                <xsl:message dpe:priority="debug" dpe:domain="{$rD}" dpe:type="{$lT}" dpe:class="{$lC}" dpe:object="{$rO}">Output context=<xsl:value-of select="dpe:local-variable('output-context')"/></xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes" dpe:priority="error" dpe:domain="{$rD}" dpe:type="{$lT}" dpe:class="{$lC}" dpe:object="{$rO}">Cannot find the output context</xsl:message>
            </xsl:otherwise>
        </xsl:choose>

        <!-- process single alternative -->
        <xsl:apply-templates select="$policy/*[local-name()='All']"/>
    </xsl:template>

    <!-- process each assertion in the alternative -->
    <xsl:template match="*[local-name()='All']">
        <xsl:apply-templates mode="assertion"/>
    </xsl:template> 

     <!-- my domain assertions -->
    
    <!-- **************************************************************** -->
    <!-- (2) Template for assertion JK-AuditLog                           -->
    <!-- **************************************************************** -->
    <xsl:template mode="assertion" match="jklw:JK-AuditLog">

        <xsl:message dpe:priority="error">Enter template JK-AuditLog: PolicyID=<xsl:value-of select="$header/dppolicy:PolicyID"/></xsl:message>
        
        <!-- The framework passed in a policykey value, this must be added to the
             processing actions in order to properly instrument source policy origin 
             information into monitoring subsystem and UI presentation -->
        <xsl:variable name="policyKey" select="./@policy-key"/>

        <xsl:variable name="config">

            <!-- **************************************************************** -->
            <!-- (5) The configuration for assertion JK-AuditLog                  -->
            <!-- **************************************************************** -->

            <!-- generate processing action to execute (assertionNo = order of processing) -->
            <!-- NOTE: previously added configuration are accessible from $configuration -->
            <dppolicy:config uri="{$nsuri}" assertionNo="{position()}" direction="{'request-rule'}">
            
                <!-- Create the name of the action. It must be unique within the DataPower Application Domain. 
                     Notes: 
                        The PolicyID will help you make the name unique, because it is unique per attachment point.
                        It is a best practice to identify the type of action in the name, to simplify debugging
                        It is also a best practice to provide a hint of the assertion this action supports in the name -->
                <xsl:variable name="actionName" select="concat($header/dppolicy:PolicyID,'-xform-', position(),'-JK-AuditLog')"/>
                
                <!-- Create the action using the name created above -->
                <xsl:element name="StylePolicyAction">
                    <xsl:attribute name="name"><xsl:value-of select="$actionName"/></xsl:attribute>
                    <xsl:element name="Type"><xsl:text>xform</xsl:text></xsl:element>
                    <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                    
                    <!-- The input and output contexts usually require special consideration
                         becasue you may want the reseult of one assertion to serve as the input 
                         of the next assertion, in which case the Input should not be INPUT and the
                         Output should not be OUTPUT. Instead use the contexts specified in the notepad
                         (which have already been placed in the local variables shown. -->
                    <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                    <xsl:element name="Output"><xsl:value-of select="dpe:local-variable('output-context')"/></xsl:element>
                    <xsl:element name="Transform"><xsl:text>store:///identity.xsl</xsl:text></xsl:element>
                    <xsl:element name="OutputType"><xsl:text>default</xsl:text></xsl:element>
                </xsl:element>
            
            </dppolicy:config>
        </xsl:variable>
        
        <!-- Send the config to the console, whatever will fit (roughly 3k) -->
        <xsl:message dpe:priority="error">Exit template JK-AuditLog - Config:
           <xsl:copy-of select="$config"/>
        </xsl:message>

        <!-- Send the config to output -->
        <xsl:copy-of select="$config"/>
    </xsl:template>



    <!-- **************************************************************** -->
    <!-- (2) Template for assertion JK-NormalizeMessage                   -->
    <!-- **************************************************************** -->
    <!-- JK-NormalizeMessage -->
    <xsl:template mode="assertion" match="jklw:JK-NormalizeMessage">
    
        <xsl:message dpe:priority="error">Enter template JK-NormalizeMessage: PolicyID=<xsl:value-of select="$header/dppolicy:PolicyID"/></xsl:message>

        <!-- The framework passed in a policykey value, this must be added to the
             processing actions in order to properly instrument source policy origin 
             information into monitoring subsystem and UI presentation -->
        <xsl:variable name="policyKey" select="./@policy-key"/>
        
        <!-- **************************************************************** -->
        <!-- (5) The configuration for assertion JK-NormalizeMessage          -->
        <!-- **************************************************************** -->
        <!-- generate processing action to execute (assertionNo = order of processing) -->
        <dppolicy:config uri="{$nsuri}" assertionNo="{position()}" direction="{'request-rule'}">

            <xsl:choose>
                <xsl:when test="./Version1">    
                    <xsl:message dpe:priority="error">JK-NormalizeMessage: V1 Message</xsl:message>
                    <xsl:variable name="actionNameValidate" select="concat($header/dppolicy:PolicyID,'-validate-', position(),'-JK-NormalizeFromV1')"/>
                    <xsl:element name="StylePolicyAction">
                        <xsl:attribute name="name"><xsl:value-of select="$actionNameValidate"/></xsl:attribute>
                        <xsl:element name="Type"><xsl:text>validate</xsl:text></xsl:element>
                        <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                        <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                        <xsl:element name="Output"><xsl:text>NULL</xsl:text></xsl:element>
                        <xsl:element name="SchemaURL">store:///JK-Version1-schema.xsd</xsl:element>     <!-- ficticious schema that validates proper V1 syntax --> 
                        <xsl:element name="SOAPValidation"><xsl:text>envelope</xsl:text></xsl:element>
                    </xsl:element>
                    
                    <xsl:variable name="actionNameXform" select="concat($header/dppolicy:PolicyID,'-xform-', position(),'-JK-NormalizeFromV1')"/>
                    <xsl:element name="StylePolicyAction">
                        <xsl:attribute name="name"><xsl:value-of select="$actionNameXform"/></xsl:attribute>
                        <xsl:element name="Type"><xsl:text>xform</xsl:text></xsl:element>
                        <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                        <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                        <xsl:element name="Output"><xsl:value-of select="dpe:local-variable('output-context')"/></xsl:element>
                        <xsl:element name="Transform"><xsl:text>store:///JK-Transform-V1-to-V3.xsl</xsl:text></xsl:element>  <!-- ficticious transform that converts V1 to V3 --> 
                        <xsl:element name="OutputType"><xsl:text>default</xsl:text></xsl:element>
                    </xsl:element>
                </xsl:when>
                <xsl:when test="./Version2">
                    <xsl:message dpe:priority="error">JK-NormalizeMessage: V2 Message</xsl:message>
                    <xsl:variable name="actionNameValidate" select="concat($header/dppolicy:PolicyID,'-validate-', position(),'-JK-NormalizeFromV2')"/>
                    <xsl:element name="StylePolicyAction">
                        <xsl:attribute name="name"><xsl:value-of select="$actionNameValidate"/></xsl:attribute>
                        <xsl:element name="Type"><xsl:text>validate</xsl:text></xsl:element>
                        <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                        <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                        <xsl:element name="Output"><xsl:text>NULL</xsl:text></xsl:element>
                        <xsl:element name="SchemaURL">store:///JK-Version2-schema.xsd</xsl:element>     <!-- ficticious schema that validates proper V1 syntax --> 
                        <xsl:element name="SOAPValidation"><xsl:text>envelope</xsl:text></xsl:element>
                    </xsl:element>
                    
                    <xsl:variable name="actionNameXform" select="concat($header/dppolicy:PolicyID,'-xform-', position(),'-JK-NormalizeFromV2')"/>
                    <xsl:element name="StylePolicyAction">
                        <xsl:attribute name="name"><xsl:value-of select="$actionNameXform"/></xsl:attribute>
                        <xsl:element name="Type"><xsl:text>xform</xsl:text></xsl:element>
                        <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                        <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                        <xsl:element name="Output"><xsl:value-of select="dpe:local-variable('output-context')"/></xsl:element>
                        <xsl:element name="Transform"><xsl:text>store:///JK-Transform-V2-to-V3.xsl</xsl:text></xsl:element>  <!-- ficticious transform that converts V1 to V3 --> 
                        <xsl:element name="OutputType"><xsl:text>default</xsl:text></xsl:element>
                    </xsl:element>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message dpe:priority="error">A malformed JK-NormalizeMessage assertion was found at <xsl:value-of select="concat($header/dppolicy:PolicyID,' position ', position())"/></xsl:message>
                </xsl:otherwise>
            </xsl:choose>
        </dppolicy:config>
        
        <xsl:message dpe:priority="error">Exit template JK-NormalizeMessage</xsl:message>
    </xsl:template>
    


    <!-- **************************************************************** -->
    <!-- (2) Template for assertion JK-RouteMessage                       -->
    <!-- **************************************************************** -->
    <xsl:template mode="assertion" match="jklw:JK-RouteMessage">
        <xsl:message dpe:priority="error">Enter template JK-RouteMessage: PolicyID=<xsl:value-of select="$header/dppolicy:PolicyID"/></xsl:message>
    
        <!-- The framework passed in a policykey value, this must be added to the
             processing actions in order to properly instrument source policy origin 
             information into monitoring subsystem and UI presentation -->
        <xsl:variable name="policyKey" select="./@policy-key"/>
        
        <!-- **************************************************************** -->
        <!-- (5) The configuration for assertion JK-RouteMessage              -->
        <!-- **************************************************************** -->
        <!-- generate processing action to execute (assertionNo = order of processing) -->
        <dppolicy:config uri="{$nsuri}" assertionNo="{position()}" direction="{'request-rule'}">

            <xsl:variable name="actionNameValidate" select="concat($header/dppolicy:PolicyID,'-call-', position(),'-JK-DetermineRoutePath')"/>
            <xsl:element name="StylePolicyAction">
                <xsl:attribute name="name"><xsl:value-of select="$actionNameValidate"/></xsl:attribute>
                <xsl:element name="Type"><xsl:text>call</xsl:text></xsl:element>
                <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                <xsl:element name="Output"><xsl:text>jk-route-context</xsl:text></xsl:element>
                <xsl:element name="NamedInOutLocationType"><xsl:text>default</xsl:text></xsl:element>
                <xsl:element name="Rule"><xsl:text>JK-routing-algorithm</xsl:text></xsl:element>       <!-- ficticious reusable rule that determines a suitable route for message -->
            </xsl:element>
            
            <xsl:variable name="actionNameXform" select="concat($header/dppolicy:PolicyID,'-xform-', position(),'-JK-RouteMessage')"/>
            <xsl:element name="StylePolicyAction">
                <xsl:attribute name="name"><xsl:value-of select="$actionNameXform"/></xsl:attribute>
                <xsl:element name="Type"><xsl:text>xform</xsl:text></xsl:element>
                <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                <xsl:element name="Input"><xsl:text>jk-route-context</xsl:text></xsl:element>
                <xsl:element name="Output">NULL</xsl:element>
                <xsl:element name="Transform"><xsl:text>store:///JK-Route.xsl</xsl:text></xsl:element> <!-- ficticious stylesheet that transform that handles the route change --> 
                <xsl:element name="OutputType"><xsl:text>default</xsl:text></xsl:element>
                <xsl:element name="StylesheetParameters">
                    <xsl:element name="ParameterName"><xsl:text>SSLProxyProfile</xsl:text></xsl:element> <!-- A SSL Proxy Profile may be needed to complete the route -->
                    <xsl:element name="ParameterValue"><xsl:value-of select="$bindings/jklw:ws-jklw-SSLProfile"/></xsl:element>
                </xsl:element>
            </xsl:element>
            
            <!-- It is very important that the output context is managed correctly,
                 In this case the jk-route-context could inadvertently become the output because it is the last output of
                 this assertion. This assertion does not transform/mediate the input so it must route the input to the output
                 explicitly. -->
            <xsl:variable name="actionNameRestoreContext" select="concat($header/dppolicy:PolicyID,'-xform-', position(),'-JK-RestoreContext')"/>
            <xsl:element name="StylePolicyAction">
                <xsl:attribute name="name"><xsl:value-of select="$actionNameRestoreContext"/></xsl:attribute>
                <xsl:element name="Type"><xsl:text>results</xsl:text></xsl:element>
                <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                <xsl:element name="Output"><xsl:value-of select="dpe:local-variable('output-context')"/></xsl:element>
            </xsl:element>

        </dppolicy:config>
        
        <xsl:message dpe:priority="error">Exit template JK-RouteMessage</xsl:message>
    </xsl:template>
    


    <!-- **************************************************************** -->
    <!-- (2) Template for assertion JK-EnforceAAA                         -->
    <!-- **************************************************************** -->
    <xsl:template mode="assertion" match="jklw:JK-EnforceAAA">
        <xsl:message dpe:priority="error">Enter template JK-EnforceAAA: PolicyID=<xsl:value-of select="$header/dppolicy:PolicyID"/></xsl:message>
        
        <!-- The framework passed in a policykey value, this must be added to the
             processing actions in order to properly instrument source policy origin 
             information into monitoring subsystem and UI presentation -->
        <xsl:variable name="policyKey" select="./@policy-key"/>
        
        <!-- **************************************************************** -->
        <!-- (5) The configuration for assertion JK-EnforceAAA              -->
        <!-- **************************************************************** -->
        <!-- generate processing action to execute (assertionNo = order of processing) -->
        <xsl:variable name="config">
            <dppolicy:config uri="{$nsuri}" assertionNo="{position()}" direction="{'request-rule'}">
                
                <!-- The StylePolicyAction created in this template references a ficticious pre-defined AAA policy. Alternatively 
                     this template can create the AAA Policy, but it must appear in config before the  AAA Action as shown in the
                     commented code below. -->
                     
                <!-- AAA Policy configuration can be large so it is a good idea to generate separate from the Actions -->
                <!-- <xsl:copy-of select="dpfunc:GetAAAPolicy()"/>   -->

                <!-- Note: If the AAA Policy referenced by this aaa action does not exist the action will remain in
                           the [down - Required referenced object not up] state and the rule containing the action will
                           remain in the down state until a valid AAA policy is created. -->
                <xsl:variable name="actionNameValidate" select="concat($header/dppolicy:PolicyID,'-call-', position(),'-JK-ApplyAAA')"/>
                <xsl:element name="StylePolicyAction">
                    <xsl:attribute name="name"><xsl:value-of select="$actionNameValidate"/></xsl:attribute>
                    <xsl:element name="Type"><xsl:text>aaa</xsl:text></xsl:element>
                    <xsl:element name="PolicyKey"><xsl:value-of select="$policyKey"/></xsl:element>
                    <xsl:element name="Input"><xsl:value-of select="dpe:local-variable('input-context')"/></xsl:element>
                    <xsl:element name="Output"><xsl:value-of select="dpe:local-variable('output-context')"/></xsl:element>
                    <xsl:element name="NamedInOutLocationType"><xsl:text>default</xsl:text></xsl:element>
                    <xsl:element name="AAA">
                        <xsl:attribute name="class"><xsl:text>AAAPolicy</xsl:text></xsl:attribute>
                        <xsl:text>JK-Standard-AAA-Policy</xsl:text>                                  <!-- The name of the AAA rule that we've already created -->
                    </xsl:element>
                </xsl:element>
        </dppolicy:config>
        
        <xsl:message dpe:priority="error">Exit template JK-EnforceAAA</xsl:message>
        </xsl:variable>
        
        <!-- Send the config to the console, whatever will fit (roughtly 3k) -->
        <xsl:message dpe:priority="error">Exit template JK-AuditLog - Config:
           <xsl:copy-of select="$config"/>
        </xsl:message>

        <!-- Send the config to the temporary://  -->
        <xsl:variable name="filename" select="concat('JK-AAA-config-',$header/dppolicy:PolicyID, '.xml')"/>
        <dpe:dump-nodes file="$filename" nodes="$config"/>

        <!-- Send the config to output -->
        <xsl:copy-of select="$config"/>
    </xsl:template>

    <!-- default catch all -->
    <xsl:template match="text()"/>


    <!-- ****************************************************************** -->
    <!-- Add code to generate a valid AAAPolicy here                        -->
    <!-- ****************************************************************** -->
    <func:function name="dpfunc:GetAAAPolicy">
                 
        <!-- Example AAA policy configuration -->
        <xsl:variable name="result">
            <!-- Add your AAAPolicy configuration here -->
        </xsl:variable>
        
        <func:result select="$result"/>
    </func:function>
                 
</xsl:stylesheet>
